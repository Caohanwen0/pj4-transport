#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, datetime, zlib

ENCODING = "utf-8"

################################

#Message Field
SEQN = "sequence num"
DATA = "data"
MSG = "msg"
CKSM = "checksum"

################################

def log(message):
    sys.stderr.write(str(message) + '\n')
    sys.stderr.flush()

# Handles receiving/outputting data messages and sending ACKs to the sender
class Receiver:
    def __init__(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  
        self.socket.bind(('0.0.0.0', 0))
        self.port = self.socket.getsockname()[1]  
        log("Bound to port %d" % self.port)

        self.remote_host = None  
        self.remote_port = None 

        self.packets = [] 
        self.output_num = -1 

    def run(self):
        while True:
            connections = select.select([self.socket], [], [])[0]
            for conn in connections:
                data, addr = conn.recvfrom(65535)

                # Grab the remote host/port if we don't already have it
                if self.remote_host is None:
                    self.remote_host = addr[0]
                    self.remote_port = addr[1]

                # handle the message
                self.recv_msg(data)

    def recv_msg(self, data):
        msg = self.parse_msg(data)
        if msg is None:
            # message was corrupted
            log('Received corrupted message')
        else:
            # message was not corrupted
            log(f"Received data message with sequence number {msg[SEQN]}")
            self.send_ack(msg[SEQN])

            if not self.was_received(msg[SEQN]):
                # this is a new packet
                self.insert_packet(msg[DATA], msg[SEQN])
                self.print_output()

    
    '''return MSG field when data is valid.
    Otherwise, return None
    '''
    @classmethod
    def parse_msg(cls, data):
        # parse json
        try:
            decoded = json.loads(data.decode(ENCODING))
        except json.decoder.JSONDecodeError:
            return None

        fields = [MSG, CKSM]
        for field in fields:
            if field not in decoded:
                return None

        fields = [SEQN, DATA] # check dict fields
        for f in fields:
            if f not in decoded[MSG]:
                return None

        # checksum
        if zlib.crc32(json.dumps(decoded[MSG], sort_keys=True).encode(ENCODING)) == decoded[CKSM]:
            return decoded[MSG]
        else:
            return None
        

    '''send ACK back to sender for receiving packet.'''
    def send_ack(self, seq_num):
        msg = {SEQN: seq_num}
        checksum = zlib.crc32(json.dumps(msg, sort_keys = True).encode(ENCODING)) 
        data = {MSG: msg, CKSM: checksum}
        log(f'Sending ACK with sequence number {seq_num}.')
        self.send(data)

    def send(self, message:dict):
        self.socket.sendto(json.dumps(message).encode(ENCODING), (self.remote_host, self.remote_port))

    '''print received data to STDOUT.'''
    def print_output(self):
        for i in range(self.output_num + 1, len(self.packets)):
            packet = self.packets[i]
            if self.was_received(i):
                self.output_num = i
                print(packet, end='', flush=True)
            else:
                return

    '''store the new arrived packet in the self.packets list.'''
    def insert_packet(self, packet, seq_num):
        if seq_num >= len(self.packets):
            self.packets += [None for _ in range(seq_num - len(self.packets))]
            self.packets.append(packet)
        else:
            self.packets[seq_num] = packet

    '''whether the packet was received'''
    def was_received(self, seq_num):
        return seq_num < len(self.packets) and self.packets[seq_num] is not None



# runs the receiver program
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='receive data')
    args = parser.parse_args()
    sender = Receiver()
    sender.run()