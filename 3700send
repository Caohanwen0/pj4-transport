#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, datetime, zlib, functools
from functools import reduce

ENCODING = "utf-8"
WINDOW_SIZE = 2
DATA_SIZE = 1425  # the maximum amount of data sent in one packet in bytes
MSG_SIZE = 1500  # the maximum size of a message in bytes that the sender expects to receive
INIT_CWND = 1 # initial congestion window size
INIT_SSTTRESH = 15
ALPHA = 0.85 # factor to update rtt estimate

################################

#Message Field
SEQN = "sequence num"
DATA = "data"
MSG = "msg"
HASH = "hash"

################################

def log(message):
    sys.stderr.write(str(message) + '\n')
    sys.stderr.flush()

def get_time():
    return int(time.time() * 1000)

class Packet:
    def __init__(self, seq_num, data, acked, send_time):
        self.seq_num = seq_num
        self.data = data
        self.acked = acked
        self.send_time = send_time

    def was_sent(self):
        return self.send_time is not None

    # determine if this packet is sent but not acked(still flying)
    def in_transit(self):
        return self.was_sent() and not self.acked
    
    # return dict 
    def get_msg_dct(self)->dict:
        self.send_time = get_time()
        msg = {
            SEQN: self.seq_num, 
            DATA: self.data
            } 
        hashed_value = zlib.crc32(json.dumps(msg , sort_keys = True).encode(ENCODING))
        data = { MSG: msg,
            HASH: hashed_value 
        }
        return data

# Handles sending data packets and receiving ACks
class Sender:
    def __init__(self, host, port):
        self.host = host 
        self.remote_port = int(port)  
        log("Sender starting up using port %s" % self.remote_port)

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))

        self.sent_packets = []
        # todo... about congestion control, yada, yada

        self.rtt = 1000
        self.ss_thresh = INIT_SSTTRESH
        self.cwnd = INIT_CWND
        
    def window(self): 
        return max(1, self.cwnd)

    '''check if all sent packets have been acked'''
    def all_acked(self):
        return functools.reduce(lambda rest, packet: packet.acked and rest, self.sent_packets)

    '''count how many packets are in transit(sent but not acknowledged)'''
    def in_transit(self):
        return functools.reduce(lambda total, pkt: total + (1 if pkt.in_transit() else 0), self.sent_packets, 0)

    def run(self):
        self.read_input()

        while True:
            inputs = [self.socket]
            connections = select.select(inputs, [], [], 0.05)[0]
            for conn in connections:
                self.receive_ack(conn)

            # todo deal with dropped packets
            self.check_dropped()
            self.send_packets()

    '''resend those packets that are 
    (1)sent (2) but not acked'''
    def check_dropped(self):
        timeout = get_time() - int(self.rtt) * 2
        for packet in self.sent_packets:
            if packet.in_transit() and packet.send_time < timeout:
                log(f"Resending dropped packet , seq number = {packet.seq_num}.")
                self.ss_thresh = self.cwnd / 2
                self.cwnd = self.ss_thresh

                self.send_msg(packet.get_msg_dct())

    '''read input from stdin'''
    def read_input(self):
        log(f"Reading data from stdin.")
        data = sys.stdin.read(DATA_SIZE)
        while len(data) > 0:
            self.sent_packets.append(Packet(len(self.sent_packets), data, False, None))
            data = sys.stdin.read(DATA_SIZE)
        log(f'Reading data get {len(self.sent_packets)} number of packets.')


    '''handle the ACK comming from conn'''
    def receive_ack(self, conn):
        data, addr = conn.recvfrom(MSG_SIZE)
        msg = self.parse_ack(data)
        if msg is None:
            log('Received corrupted ACK packet.')
        else:
            log(f'Received ACK: {json.dumps(msg, indent=2)}')

            packet = self.sent_packets[msg[SEQN]]
            packet.acked = True # mark the packet as ACKed.

            # todo: congestion control here...
            self.rtt = ALPHA * self.rtt + (1 - ALPHA) * (get_time() - packet.send_time)
            if self.cwnd < self.ss_thresh: # when cwnd is below threshhold
                # exponential growth
                self.cwnd += 1
            else:
                # linear growth
                self.cwnd += 1 / self.cwnd

            # exit if all packets have been successfully received
            if self.all_acked():
                log('All done!!!')
                exit(0)

    def send_msg(self, message:dict):
        self.socket.sendto(json.dumps(message).encode('utf-8'), (self.host, self.remote_port))

    def send_packets(self):
        # todo...window size
        delta = self.window() - self.in_transit()
        log(f"Current maximum window size is {delta}.")
        i = 0
        while i < len(self.sent_packets) and delta > 0:
            packet = self.sent_packets[i]
            if not packet.was_sent():
                log(f"Sending data to receiver: sequence number is {i}")
                self.send_msg(packet.get_msg_dct())
                delta -= 1
            i += 1

    '''parsing ACK message 
    If having legal format, return MSG field
    Otherwise, return None
    '''
    @classmethod
    def parse_ack(cls, data):
        try: # json format
            msg = json.loads(data.decode(ENCODING))
        except json.decoder.JSONDecodeError:
            return None

        # check outer layer
        valid_fields = [MSG, HASH]
        for field in valid_fields:
            if field not in msg:
                return None
        

        valid_fields = [SEQN,]
        for field in valid_fields:
            if field not in msg[MSG]: # check field
                return None

        # checksum
        if zlib.crc32(json.dumps(msg[MSG], sort_keys=True).encode(ENCODING)) == msg[HASH]:
            return msg[MSG]
        else:
            return None
        


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('host', type=str, help="Remote host to connect to")
    parser.add_argument('port', type=int, help="UDP port number to connect to")
    args = parser.parse_args()
    sender = Sender(args.host, args.port)
    sender.run()